/* ###################################################################
**     THIS COMPONENT MODULE IS GENERATED BY THE TOOL. DO NOT MODIFY IT.
**     Filename    : BT1.c
**     Project     : FRDM_RTOS_TestCar_V1.2
**     Processor   : MKL25Z128VLK4
**     Component   : Bluetooth_EGBT
**     Version     : Component 01.053, Driver 01.00, CPU db: 3.00.000
**     Compiler    : GNU C Compiler
**     Date/Time   : 2017-03-23, 17:24, # CodeGen: 129
**     Abstract    :
**          Driver for e-Gizmo Bluetooth module
**     Settings    :
**          Component name                                 : BT1
**          Firmware                                       : HC05
**          Response timeout (ms)                          : 650
**          CMD Pin                                        : Disabled
**          State Pin                                      : Enabled
**            State Pin                                    : StatePin
**          Rx Pull-Up                                     : Disabled
**          Interfaces                                     : 
**            Shell                                        : CLS1
**            Utility                                      : UTIL1
**            Wait                                         : WAIT1
**            Serial                                       : Serial
**     Contents    :
**         Init                                                - void BT1_Init(void);
**         Deinit                                              - void BT1_Deinit(void);
**         GetLastError                                        - BT1_TEnumErrors BT1_GetLastError(void);
**         GetErrorString                                      - BT1_TConstStringPtr BT1_GetErrorString(BT1_TEnumErrors errorNo);
**         SendATCommand                                       - byte BT1_SendATCommand(byte *cmd, byte *rxBuf, size_t rxBufSize, byte...
**         StdCmd                                              - byte BT1_StdCmd(byte *cmd, byte *rxBuf, size_t rxBufSize, byte...
**         StdOKCmd                                            - byte BT1_StdOKCmd(byte *cmd);
**         QueryString                                         - byte BT1_QueryString(byte *cmd, byte *expectedResponse, byte *string, size_t...
**         btTestUART                                          - byte BT1_btTestUART(void);
**         btResetDevice                                       - byte BT1_btResetDevice(void);
**         btQueryFirmwareVersionStr                           - byte BT1_btQueryFirmwareVersionStr(byte *buf, size_t bufSize);
**         btRestoreFactoryDefault                             - byte BT1_btRestoreFactoryDefault(void);
**         btQueryBluetoothAddressStr                          - byte BT1_btQueryBluetoothAddressStr(byte *buf, size_t bufSize);
**         btQueryDeviceName                                   - byte BT1_btQueryDeviceName(byte *buf, size_t bufSize);
**         btSetDeviceName                                     - byte BT1_btSetDeviceName(byte *name);
**         btQueryRemoteBluetoothDeviceName                    - byte BT1_btQueryRemoteBluetoothDeviceName(byte *buf, size_t bufSize);
**         btQueryRole                                         - byte BT1_btQueryRole(byte *role);
**         btSetRole                                           - byte BT1_btSetRole(byte role);
**         btQueryCoDStr                                       - byte BT1_btQueryCoDStr(byte *buf, size_t bufSize);
**         btSetCoDStr                                         - byte BT1_btSetCoDStr(byte *classStr);
**         btQueryIACStr                                       - byte BT1_btQueryIACStr(byte *buf, size_t bufSize);
**         btSetIACStr                                         - byte BT1_btSetIACStr(byte *iac);
**         btQueryIAMStr                                       - byte BT1_btQueryIAMStr(byte *buf, size_t bufSize);
**         btSetIAMStr                                         - byte BT1_btSetIAMStr(byte *iam);
**         btQueryPairingPasskey                               - byte BT1_btQueryPairingPasskey(byte *buf, size_t bufSize);
**         btSetPairingPasskey                                 - byte BT1_btSetPairingPasskey(byte *pwd);
**         btQueryUARTParametersStr                            - byte BT1_btQueryUARTParametersStr(byte *buf, size_t bufSize);
**         btSetUARTParameterStr                               - byte BT1_btSetUARTParameterStr(byte *param);
**         btSetBaud                                           - byte BT1_btSetBaud(dword baud);
**         btQueryConnectionMethod                             - byte BT1_btQueryConnectionMethod(byte *method);
**         btSetConnectionMethod                               - byte BT1_btSetConnectionMethod(byte method);
**         btQueryBindingBluetoothAddress                      - byte BT1_btQueryBindingBluetoothAddress(byte *buf, size_t bufSize);
**         btSetBindingBluetoothStr                            - byte BT1_btSetBindingBluetoothStr(byte *addr);
**         btQueryLEDOutputPolarityStr                         - byte BT1_btQueryLEDOutputPolarityStr(byte *buf, size_t bufSize);
**         btSetLEDOutputPolarityStr                           - byte BT1_btSetLEDOutputPolarityStr(byte *ledPolarityStr);
**         btSetUserPinIO                                      - byte BT1_btSetUserPinIO(byte portNumber, bool on);
**         btSetMultipleUserIOPins                             - byte BT1_btSetMultipleUserIOPins(word mask);
**         btQueryMultipleUserIOPinsStr                        - byte BT1_btQueryMultipleUserIOPinsStr(byte *buf, size_t bufSize);
**         btQueryMultipleUserIOPins                           - byte BT1_btQueryMultipleUserIOPins(word *mask);
**         btQueryScanningParametersStr                        - byte BT1_btQueryScanningParametersStr(byte *buf, size_t bufSize);
**         btSetScanningParameterStr                           - byte BT1_btSetScanningParameterStr(byte *param);
**         btQuerySNIFFParametersStr                           - byte BT1_btQuerySNIFFParametersStr(byte *buf, size_t bufSize);
**         btSetSNIFFParameterStr                              - byte BT1_btSetSNIFFParameterStr(byte *param);
**         btQuerySecurityEncryptionModesStr                   - byte BT1_btQuerySecurityEncryptionModesStr(byte *buf, size_t bufSize);
**         btSetSecurityEncryptionModesStr                     - byte BT1_btSetSecurityEncryptionModesStr(byte *modes);
**         btDeleteAuthenticatedDeviceFromListStr              - byte BT1_btDeleteAuthenticatedDeviceFromListStr(byte *addrString);
**         btFindDeviceFromAuthenticatedDeviceListStr          - byte BT1_btFindDeviceFromAuthenticatedDeviceListStr(byte *addrString);
**         btQueryTotalNumberOfDeviceFromAuthenticationListStr - byte BT1_btQueryTotalNumberOfDeviceFromAuthenticationListStr(byte *buf,...
**         btQueryTotalNumberOfDeviceFromAuthenticationList    - byte BT1_btQueryTotalNumberOfDeviceFromAuthenticationList(byte *nofDevices);
**         btQueryMostRecentlyUsedAuthenticatedDevice          - byte BT1_btQueryMostRecentlyUsedAuthenticatedDevice(byte *buf, size_t bufSize);
**         btQueryCurrentStateOfDeviceStr                      - byte BT1_btQueryCurrentStateOfDeviceStr(byte *buf, size_t bufSize);
**         ParseCommand                                        - byte BT1_ParseCommand(const unsigned char* cmd, bool *handled, const...
**         RecvChar                                            - byte BT1_RecvChar(byte *ch);
**         SendChar                                            - byte BT1_SendChar(byte ch);
**         GetCharsInRxBuf                                     - word BT1_GetCharsInRxBuf(void);
**         StdIOKeyPressed                                     - bool BT1_StdIOKeyPressed(void);
**         StdIOReadChar                                       - void BT1_StdIOReadChar(byte *c);
**         StdIOSendChar                                       - void BT1_StdIOSendChar(byte ch);
**
**     * Copyright (c) 2013-2016, Erich Styger
**      * Web:         https://mcuoneclipse.com
**      * SourceForge: https://sourceforge.net/projects/mcuoneclipse
**      * Git:         https://github.com/ErichStyger/McuOnEclipse_PEx
**      * All rights reserved.
**      *
**      * Redistribution and use in source and binary forms, with or without modification,
**      * are permitted provided that the following conditions are met:
**      *
**      * - Redistributions of source code must retain the above copyright notice, this list
**      *   of conditions and the following disclaimer.
**      *
**      * - Redistributions in binary form must reproduce the above copyright notice, this
**      *   list of conditions and the following disclaimer in the documentation and/or
**      *   other materials provided with the distribution.
**      *
**      * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
**      * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
**      * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
**      * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
**      * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
**      * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
**      * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
**      * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
**      * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
**      * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
** ###################################################################*/
/*!
** @file BT1.c
** @version 01.00
** @brief
**          Driver for e-Gizmo Bluetooth module
*/         
/*!
**  @addtogroup BT1_module BT1 module documentation
**  @{
*/         

/* MODULE BT1. */

#include "BT1.h"

/* No cmd pin configured */
#define BT1_SET_CMD_MODE()                          /* do nothing */
#define BT1_SET_DATA_MODE()                         /* do nothing */
#define BT1_CLR_RX_BUF()                            (void)Serial1_ClearRxBuf() /* clear input buffer */

/* default standard I/O struct */
CLS1_ConstStdIOType BT1_stdio = {
    (CLS1_StdIO_In_FctType)BT1_StdIOReadChar, /* stdin */
    (CLS1_StdIO_OutErr_FctType)BT1_StdIOSendChar, /* stdout */
    (CLS1_StdIO_OutErr_FctType)BT1_StdIOSendChar, /* stderr */
    BT1_StdIOKeyPressed /* if input is not empty */
  };
uint8_t BT1_DefaultShellBuffer[CLS1_DEFAULT_SHELL_BUFFER_SIZE]; /* default buffer which can be used by the application */

static BT1_TEnumErrors BT1_lastErr = BT1_NO_ERROR; /* holds the last error */

static const unsigned char *BT1_ErrorStringTable[] = {
  /*  0 */ (unsigned char*)"Command Error/Invalid Command",
  /*  1 */ (unsigned char*)"Results in default value",
  /*  2 */ (unsigned char*)"PSKEY write error",
  /*  3 */ (unsigned char*)"Device name too long (>32 characters)",
  /*  4 */ (unsigned char*)"No device name specified (0 length)",
  /*  5 */ (unsigned char*)"Bluetooth address NAP is too long",
  /*  6 */ (unsigned char*)"Bluetooth address UAP is too long",
  /*  7 */ (unsigned char*)"Bluetooth address LAP is too long",
  /*  8 */ (unsigned char*)"PIO map not specified (0 length)",
  /*  9 */ (unsigned char*)"Invalid PIO port number entered",
  /*  A */ (unsigned char*)"Device Class is not specified (0 length)",
  /*  B */ (unsigned char*)"Device Class too long",
  /*  C */ (unsigned char*)"Inquire Access Code not specified (0 length)",
  /*  D */ (unsigned char*)"Inquire Access Code too long",
  /*  E */ (unsigned char*)"Invalid Inquire Access code entered",
  /*  F */ (unsigned char*)"Pairing Password not specified (0 length)",
  /* 10 */ (unsigned char*)"Pairing Password too long (>16 characters)",
  /* 11 */ (unsigned char*)"Invalid Role entered",
  /* 12 */ (unsigned char*)"Invalid Baud Rate entered",
  /* 13 */ (unsigned char*)"Invalid Stop Bit entered",
  /* 14 */ (unsigned char*)"Invalid Parity Bit entered",
  /* 15 */ (unsigned char*)"No device in Pairing List",
  /* 16 */ (unsigned char*)"SPP not initialized",
  /* 17 */ (unsigned char*)"SPP already initialized",
  /* 18 */ (unsigned char*)"Invalid Inquiry Mode",
  /* 19 */ (unsigned char*)"Inquire Timeout occurred",
  /* 1A */ (unsigned char*)"Invalid/zero length address entered",
  /* 1B */ (unsigned char*)"Invalid Security Mode entered",
  /* 1C */ (unsigned char*)"Invalid Encryption Mode entered",
  /* 1D */ (unsigned char*)"No Error",
};

static bool isRxError(unsigned char *buf, BT1_TEnumErrors *errno)
{
  /* return true for "ERROR:(1D)\r\n" at the end of the buffer and returns the error */
  size_t idx;
  unsigned char ch_low, ch_high;
  const unsigned char *p;
  uint8_t val;
  unsigned char hexBuf[sizeof("0x1F")];
  #define _IS_ERR_NUMBER(ch) ((ch>='0' && ch<='9') || (ch>='A' && ch<='D')) /* 0..1D */

  idx = UTIL1_strlen((char*)buf);
  if (idx >= sizeof("ERROR(0)\r\n")) {
    if (UTIL1_strtailcmp(buf, (unsigned char*)")\r\n") == 0) {
      if (UTIL1_strncmp((char*)&buf[idx - sizeof("ERROR(0)\r\n") - 1], (char*)"ERROR(", sizeof("ERROR(")) == 0) {
        ch_high = '0';
        ch_low = buf[idx-sizeof("0)\r\n")-1];
      } else if (UTIL1_strncmp((char*)&buf[idx - sizeof("ERROR(00)\r\n") - 1], (char*)"ERROR(", sizeof("ERROR(")) == 0) {
        ch_high = buf[idx - sizeof("00)\r\n") - 1];
        ch_low = buf[idx - sizeof("0)\r\n") - 1];
      } else { /* initialize in any case */
        ch_high = '\0';
        ch_low = '\0';
      }
      if (_IS_ERR_NUMBER(ch_high) && _IS_ERR_NUMBER(ch_low)) {
        UTIL1_strcpy(hexBuf, sizeof(hexBuf), (unsigned char*)"0x");
        UTIL1_chcat(hexBuf, sizeof(hexBuf), ch_high);
        UTIL1_chcat(hexBuf, sizeof(hexBuf), ch_low);
        p = &hexBuf[0];
        if (UTIL1_ScanHex8uNumber(&p, &val) == ERR_OK) {
          *errno = (BT1_TEnumErrors)val;
          return TRUE; /* bingo! */
        }
      }
    }
  }
  return FALSE; /* not an error */
}

static uint8_t RxResponse(unsigned char *rxBuf, size_t rxBufLength, uint16_t msTimeout, unsigned char *expectedTail)
{
  unsigned char ch;
  uint8_t res = ERR_OK;
  unsigned char *p;

  if (rxBufLength < sizeof("x\r\n")) {
    return ERR_OVERFLOW; /* not enough space in buffer */
  }
  p = rxBuf;
  p[0] = '\0';
  for(;;) { /* breaks */
    if (msTimeout == 0) {
      break; /* will decide outside of loop if it is a timeout. */
    } else if (rxBufLength == 0) {
      res = ERR_OVERFLOW; /* not enough space in buffer */
      break;
    } else if (Serial1_GetCharsInRxBuf() > 0) {
      if (Serial1_RecvChar(&ch) != ERR_OK) {
        res = ERR_RXEMPTY;
        break;
      }
      *p++ = ch;
      *p = '\0'; /* always terminate */
      rxBufLength--;
    } else if (expectedTail[0] != '\0'
    			&& UTIL1_strtailcmp(rxBuf, expectedTail) == 0) {
      break; /* finished */
    } else if (isRxError(rxBuf, &BT1_lastErr)) {
      break; /* error */
    } else {
      WAIT1_WaitOSms(1);
      msTimeout--;
    }
  } /* for */
  if (msTimeout==0) { /* timeout! */
    if (expectedTail[0] != '\0' /* timeout, and we expected something: an error for sure */
        || rxBuf[0] == '\0' /* timeout, did not know what to expect, but received nothing? There has to be a response. */
       )
    {
      res = ERR_FAULT;
    }
  }
  return res;
}

static uint8_t ExecuteQueryString(uint8_t(*f)(unsigned char*,size_t), unsigned char *buf, size_t bufSize, unsigned char *appendStr)
{
  byte status = f(buf, bufSize);
  if (status == ERR_OK) {
    UTIL1_strcat(buf, bufSize, (unsigned char*)appendStr);
    return ERR_OK;
  } else {
    UTIL1_strcpy(buf, bufSize, (unsigned char*)"ERROR");
    UTIL1_strcat(buf, bufSize, (unsigned char*)appendStr);
    return ERR_FAILED;
  }
}

static uint8_t PrintShortStatus(const CLS1_StdIOType *io)
{
  uint8_t res = ERR_OK;

  CLS1_SendStatusStr((unsigned char*)"BT1", (unsigned char*)"\r\n", io->stdOut);
  if (BT1_btTestUART()!=ERR_OK) {
    CLS1_SendStatusStr((unsigned char*)"  Test UART", (unsigned char*)"FAILED", io->stdOut);
    /* even if it failed, this is most likely because we are in transparent mode, so that would be ok */
  } else {
    CLS1_SendStatusStr((unsigned char*)"  Test UART", (unsigned char*)"OK", io->stdOut);
  }
  CLS1_SendStr((unsigned char*)" (use 'BT1 status' for full status)\r\n", io->stdOut);
  return res;
}

static uint8_t PrintLongStatus(const CLS1_StdIOType *io)
{
  uint8_t buf[BT1_MAX_RESPONSE_SIZE];

  CLS1_SendStatusStr((unsigned char*)"BT1", (unsigned char*)"\r\n", io->stdOut);

  if (BT1_btTestUART() != ERR_OK) {
    CLS1_SendStatusStr((unsigned char*)"  Test UART", (unsigned char*)"FAILED\r\n", io->stdOut);
    return ERR_FAILED;
  } else {
    CLS1_SendStatusStr((unsigned char*)"  Test UART", (unsigned char*)"OK\r\n", io->stdOut);
  }

  (void)ExecuteQueryString(BT1_btQueryFirmwareVersionStr, buf, sizeof(buf), (unsigned char*)"\r\n");
  CLS1_SendStatusStr((unsigned char*)"  Firmware", buf, io->stdOut);

  (void)ExecuteQueryString(BT1_btQueryDeviceName, buf, sizeof(buf), (unsigned char*)"\r\n");
  CLS1_SendStatusStr((unsigned char*)"  Name", buf, io->stdOut);

  (void)ExecuteQueryString(BT1_btQueryBluetoothAddressStr, buf, sizeof(buf), (unsigned char*)"\r\n");
  CLS1_SendStatusStr((unsigned char*)"  Address", buf, io->stdOut);

  (void)ExecuteQueryString(BT1_btQueryIACStr, buf, sizeof(buf), (unsigned char*)"\r\n");
  CLS1_SendStatusStr((unsigned char*)"  IAC", buf, io->stdOut);

  (void)ExecuteQueryString(BT1_btQueryIAMStr, buf, sizeof(buf), (unsigned char*)"\r\n");
  CLS1_SendStatusStr((unsigned char*)"  IAM", buf, io->stdOut);

  (void)ExecuteQueryString(BT1_btQueryPairingPasskey, buf, sizeof(buf), (unsigned char*)"\r\n");
  CLS1_SendStatusStr((unsigned char*)"  Pairing Key", buf, io->stdOut);

  (void)ExecuteQueryString(BT1_btQueryUARTParametersStr, buf, sizeof(buf), (unsigned char*)"\r\n");
  CLS1_SendStatusStr((unsigned char*)"  UART Param", buf, io->stdOut);

  (void)ExecuteQueryString(BT1_btQueryBindingBluetoothAddress, buf, sizeof(buf), (unsigned char*)"\r\n");
  CLS1_SendStatusStr((unsigned char*)"  BindingAddr", buf, io->stdOut);

  (void)ExecuteQueryString(BT1_btQueryLEDOutputPolarityStr, buf, sizeof(buf), (unsigned char*)"\r\n");
  CLS1_SendStatusStr((unsigned char*)"  LEDPolarity", buf, io->stdOut);

  (void)ExecuteQueryString(BT1_btQueryScanningParametersStr, buf, sizeof(buf), (unsigned char*)"\r\n");
  CLS1_SendStatusStr((unsigned char*)"  Scan Param", buf, io->stdOut);

  (void)ExecuteQueryString(BT1_btQuerySNIFFParametersStr, buf, sizeof(buf), (unsigned char*)"\r\n");
  CLS1_SendStatusStr((unsigned char*)"  SNIFF Param", buf, io->stdOut);

  (void)ExecuteQueryString(BT1_btQuerySecurityEncryptionModesStr, buf, sizeof(buf), (unsigned char*)"\r\n");
  CLS1_SendStatusStr((unsigned char*)"  Encryption", buf, io->stdOut);

  (void)ExecuteQueryString(BT1_btQueryMostRecentlyUsedAuthenticatedDevice, buf, sizeof(buf), (unsigned char*)"\r\n");
  CLS1_SendStatusStr((unsigned char*)"  Recent Auth.", buf, io->stdOut);

  (void)ExecuteQueryString(BT1_btQueryCurrentStateOfDeviceStr, buf, sizeof(buf), (unsigned char*)"\r\n");
  CLS1_SendStatusStr((unsigned char*)"  State", buf, io->stdOut);

  (void)ExecuteQueryString(BT1_btQueryTotalNumberOfDeviceFromAuthenticationListStr, buf, sizeof(buf), (unsigned char*)"\r\n");
  CLS1_SendStatusStr((unsigned char*)"  Nof Auth.", buf, io->stdOut);

  (void)ExecuteQueryString(BT1_btQueryMultipleUserIOPinsStr, buf, sizeof(buf), (unsigned char*)"\r\n");
  CLS1_SendStatusStr((unsigned char*)"  I/O Pins", buf, io->stdOut);

  if (BT1_btQueryRole(&buf[0])!=ERR_OK) {
    UTIL1_strcpy(buf, sizeof(buf), (unsigned char*)"ERROR\r\n");
  } else {
    buf[1] = '\0';
    if (buf[0] == '0') {
      UTIL1_strcat(buf, sizeof(buf), (unsigned char*)" (slave)\r\n");
    } else if (buf[0] == '1') {
      UTIL1_strcat(buf, sizeof(buf), (unsigned char*)" (master)\r\n");
    } else if (buf[0] == '2') {
      UTIL1_strcat(buf, sizeof(buf), (unsigned char*)" (slave-loop)\r\n");
    } else {
      UTIL1_strcat(buf, sizeof(buf), (unsigned char*)" (UNKNOWN)\r\n");
    }
  }
  CLS1_SendStatusStr((unsigned char*)"  Role", buf, io->stdOut);

  if (BT1_btQueryConnectionMethod(&buf[0])!=ERR_OK) {
    UTIL1_strcpy(buf, sizeof(buf), (unsigned char*)"ERROR\r\n");
  } else {
    buf[1] = '\0';
    if (buf[0] == '0') {
      UTIL1_strcat(buf, sizeof(buf), (unsigned char*)" (specific address only)\r\n");
    } else if (buf[0] == '1') {
      UTIL1_strcat(buf, sizeof(buf), (unsigned char*)" (any address)\r\n");
    } else if (buf[0] == '2') {
      UTIL1_strcat(buf, sizeof(buf), (unsigned char*)" (test mode)\r\n");
    } else {
      UTIL1_strcat(buf, sizeof(buf), (unsigned char*)" (UNKNOWN)\r\n");
    }
  }
  CLS1_SendStatusStr((unsigned char*)"  Connection", buf, io->stdOut);
  return ERR_OK;
}

static uint8_t PrintHelp(const CLS1_StdIOType *io)
{
  CLS1_SendHelpStr((unsigned char*)"BT1", (unsigned char*)"Group of BT1 commands\r\n", io->stdOut);
  CLS1_SendHelpStr((unsigned char*)"  help|status", (unsigned char*)"Print help or status information\r\n", io->stdOut);
  CLS1_SendHelpStr((unsigned char*)"  pin <pin>", (unsigned char*)"Set pairing pin, e.g. 'BT1 pin 1234'\r\n", io->stdOut);
  CLS1_SendHelpStr((unsigned char*)"  name <name>", (unsigned char*)"Set device name e.g. 'BT1 name Blue'\r\n", io->stdOut);
  CLS1_SendHelpStr((unsigned char*)"  baud <baud>", (unsigned char*)"Set baud (1200, 2400, 4800, ... 115200), e.g. 'BT1 baud 9600'\r\n", io->stdOut);
#ifdef BT1_FIRMWARE_HC05 /* HC06 does not need \r\n */
  CLS1_SendHelpStr((unsigned char*)"  cmd <AT command>", (unsigned char*)"Send an AT command, e.g AT+NAME?\r\n", io->stdOut);
#else
  CLS1_SendHelpStr((unsigned char*)"  cmd <AT command>", (unsigned char*)"Send an AT command, e.g AT+VERSION\r\n", io->stdOut);
#endif
  CLS1_SendHelpStr((unsigned char*)"  send <string>", (unsigned char*)"Send a string to the Bluetooth UART bridge\r\n", io->stdOut);
  return ERR_OK;
}

static uint8_t SendCommand(const unsigned char *cmd, const CLS1_StdIOType *io)
{
  unsigned char buf[BT1_MAX_RESPONSE_SIZE];
  unsigned char cmdBuf[BT1_MAX_AT_CMD_SIZE];
  uint8_t res = ERR_OK;

  UTIL1_strcpy(cmdBuf, sizeof(cmdBuf), cmd);
  UTIL1_strcat(cmdBuf, sizeof(cmdBuf), (unsigned char*)"\r\n");
  buf[0] = '\0';
  if (BT1_SendATCommand(cmdBuf, buf, sizeof(buf), (unsigned char*)"OK\r\n") != ERR_OK) {
    CLS1_SendStr((unsigned char*)"***Response not OK\r\n", io->stdOut);
    res = ERR_FAILED;
  }
  CLS1_SendStr(buf, io->stdOut);
  return res;
}

/*
** ===================================================================
**     Method      :  BT1_SendATCommand (component Bluetooth_EGBT)
**     Description :
**         Sends an AT command string (with the AT in it) to the module.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * cmd             - Pointer to AT command string with the AT
**                           in it
**       * rxBuf           - Pointer to buffer for the response
**                           from the device
**         rxBufSize       - size of the receiving buffer
**                           in bytes
**       * expectedTailStr - Pointer to the
**                           function will read from the device until
**                           the expected tail string is read. Typically
**                           this is "OK" terminated by backslash r and
**                           backslash n
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte BT1_SendATCommand(byte *cmd, byte *rxBuf, size_t rxBufSize, byte *expectedTailStr)
{
  word snt;
  byte res;

  BT1_SET_CMD_MODE();
  BT1_CLR_RX_BUF();
  if (Serial1_SendBlock(cmd, (word)UTIL1_strlen((char*)cmd), &snt) != ERR_OK) {
    return ERR_FAILED;
  }
  res = RxResponse(rxBuf, rxBufSize, BT1_TIMEOUT_MS, expectedTailStr);
  BT1_SET_DATA_MODE();
  return res;
}

/*
** ===================================================================
**     Method      :  BT1_StdCmd (component Bluetooth_EGBT)
**     Description :
**         Send standard command: "<cmd>\r
**         " ==> "<expectedResponse>"
**     Parameters  :
**         NAME            - DESCRIPTION
**       * cmd             - Pointer to command string
**       * rxBuf           - Pointer to buffer for the answer
**         rxBufSize       - 
**       * expectedResponse - Pointer to
**                           expected response
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte BT1_StdCmd(byte *cmd, byte *rxBuf, size_t rxBufSize, byte *expectedResponse)
{
  /* Send standard command: "<cmd>\r\n" ==> "<expectedResponse>" */
  uint8_t res = ERR_OK;
  unsigned char cmdBuf[BT1_MAX_AT_CMD_SIZE];

  UTIL1_strcpy(cmdBuf, sizeof(cmdBuf), cmd);
  /* HC05 AND BC04 firmware has \r\n line ending */
  UTIL1_strcat(cmdBuf, sizeof(cmdBuf), (unsigned char*)"\r\n");
  for(;;) { /* breaks */
    if (BT1_SendATCommand(cmdBuf, rxBuf, rxBufSize, expectedResponse) != ERR_OK) {
      res = ERR_FAILED;
      break;
    }
    if (UTIL1_strcmp((char*)rxBuf, (char*)expectedResponse) != 0) {
      res = ERR_FAILED;
      break;
    }
    break; /* exit for(;;) */
  } /* for */
  return res;
}

/*
** ===================================================================
**     Method      :  BT1_StdOKCmd (component Bluetooth_EGBT)
**     Description :
**         Send standard command: "<cmd>\r
**         " ==> "OK\r
**         "
**     Parameters  :
**         NAME            - DESCRIPTION
**       * cmd             - Pointer to command string
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte BT1_StdOKCmd(byte *cmd)
{
  /* Send standard command: "<cmd>\r\n" ==> "OK\r\n" */
  unsigned char rxBuf[sizeof("FAIL\r\n")+1]; /* could be FAIL or OK */

  /* HC05 firmware has \r\n line ending */
  return BT1_StdCmd(cmd, rxBuf, sizeof(rxBuf), (unsigned char*)"OK\r\n");
}

/*
** ===================================================================
**     Method      :  BT1_QueryString (component Bluetooth_EGBT)
**     Description :
**         get string from device: "<cmd>\r
**         " ==> "<response><string>\r
**         OK\r
**         "
**     Parameters  :
**         NAME            - DESCRIPTION
**       * cmd             - Pointer to command string
**       * expectedResponse - Pointer to
**                           expected response string
**       * string          - Pointer to buffer where to store the
**                           string value
**         stringSize      - 
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte BT1_QueryString(byte *cmd, byte *expectedResponse, byte *string, size_t stringSize)
{
  /* get string: "<cmd>\r\n" ==> "<expectedResponse><string>\r\nOK\r\n" */
  /* example get string: "AT+RNAME?\r\n" ==> "+NAME:<name>\r\nOK\r\n"
    cmd: "AT+RNAME?\r\n"
    expected response: "+NAME:"
  */
  uint8_t res = ERR_OK;
  unsigned char rxBuf[BT1_MAX_RESPONSE_SIZE];
  unsigned char cmdBuf[BT1_MAX_AT_CMD_SIZE];
  size_t responseLen;

  responseLen = UTIL1_strlen((char*)expectedResponse);
  string[0] = '\0'; /* initialize buffer */
  UTIL1_strcpy(cmdBuf, sizeof(cmdBuf), cmd);
  /* HC05 and BC04 firmware have \r\n line ending */
  UTIL1_strcat(cmdBuf, sizeof(cmdBuf), (unsigned char*)"\r\n");
  for(;;) { /* breaks */
	/* HC05 firmware has \r\n line ending */
    if (BT1_SendATCommand(cmdBuf, rxBuf, sizeof(rxBuf), (unsigned char*)"\r\nOK\r\n") != ERR_OK) {
      res = ERR_FAILED;
      break;
    }
    if (UTIL1_strncmp((char*)rxBuf, (char*)expectedResponse, responseLen) != 0) {
      res = ERR_FAILED;
      break;
    }
	/* HC05 firmware has \r\n line ending */
    if (UTIL1_strCutTail(rxBuf, (unsigned char*)"\r\nOK\r\n") != ERR_OK) {
      res = ERR_FAILED;
      break;
    }
    UTIL1_strcpy(string, stringSize, &rxBuf[responseLen]); /* store name */
    break; /* exit for(;;) */
  } /* for */
  return res;
}

/*
** ===================================================================
**     Method      :  BT1_GetLastError (component Bluetooth_EGBT)
**     Description :
**         Returns the last error reported by the device.
**     Parameters  : None
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
BT1_TEnumErrors BT1_GetLastError(void)
{
  BT1_TEnumErrors err = BT1_lastErr;

  BT1_lastErr = BT1_NO_ERROR; /* reset error */
  return err;
}

/*
** ===================================================================
**     Method      :  BT1_GetErrorString (component Bluetooth_EGBT)
**     Description :
**         Returns for a given error code the error string describing
**         the problem.
**     Parameters  :
**         NAME            - DESCRIPTION
**         errorNo         - 
**     Returns     :
**         ---             - Error string
** ===================================================================
*/
BT1_TConstStringPtr BT1_GetErrorString(BT1_TEnumErrors errorNo)
{
  if (errorNo>BT1_NO_ERROR) {
    return (unsigned char*)"***illegal error number";
  }
  return BT1_ErrorStringTable[errorNo];
}

/*
** ===================================================================
**     Method      :  BT1_Init (component Bluetooth_EGBT)
**     Description :
**         Initializes the module
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
void BT1_Init(void)
{
  BT1_lastErr = BT1_NO_ERROR; /* reset error */
}

/*
** ===================================================================
**     Method      :  BT1_Deinit (component Bluetooth_EGBT)
**     Description :
**         Deinitializes the module
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
void BT1_Deinit(void)
{
  /* nothing to do */
}

/*
** ===================================================================
**     Method      :  BT1_btTestUART (component Bluetooth_EGBT)
**     Description :
**         Tests the UAR connection with AT
**     Parameters  : None
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte BT1_btTestUART(void)
{
#ifdef BT1_FIRMWARE_HC05
  /* 1: Test UART connection: "AT\r\n" ==> "OK\r\n" */
#else /* HC06 */
  /* 1: Test UART connection: "AT" ==> "OK" */
#endif
  return BT1_StdOKCmd((unsigned char*)"AT");
}

/*
** ===================================================================
**     Method      :  BT1_btResetDevice (component Bluetooth_EGBT)
**     Description :
**         Resets the device with AT+RESET
**     Parameters  : None
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte BT1_btResetDevice(void)
{
  /* 2: Reset device: "AT+RESET\r\n" ==> "OK\r\n" */
  return BT1_StdOKCmd((unsigned char*)"AT+RESET");
}

/*
** ===================================================================
**     Method      :  BT1_btQueryFirmwareVersionStr (component Bluetooth_EGBT)
**     Description :
**         Queries the firmware version
**     Parameters  :
**         NAME            - DESCRIPTION
**       * buf             - Pointer to buffer where to store the string
**         bufSize         - Size of the buffer in bytes.
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte BT1_btQueryFirmwareVersionStr(byte *buf, size_t bufSize)
{
  /* 3: Query firmware version: "AT+VERSION?\r\n" ==> "+VERSION:<VER>\r\nOK\r\n" */
  return BT1_QueryString((unsigned char*)"AT+VERSION?", (unsigned char*)"+VERSION:", buf, bufSize);
}

/*
** ===================================================================
**     Method      :  BT1_btRestoreFactoryDefault (component Bluetooth_EGBT)
**     Description :
**         Restores the factory defaults on the device
**     Parameters  : None
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte BT1_btRestoreFactoryDefault(void)
{
  /* 4: Restore settings to factory default: "AT+ORGL\r\n" ==> "OK\r\n" */
  /*
    Restore to the following settings:
    Device Class: 0
    Inquiry Code: 0x009e8b33
    Device Mode: Slave
    Binding Mode: SPP
    UART: 38400bps, 8 bit, 1 stop bit, no parity
    Pairing Code: 1234
    Device Name: H-C-2010-06-01
   */
  return BT1_StdOKCmd((unsigned char*)"AT+ORGL");
}

/*
** ===================================================================
**     Method      :  BT1_btQueryBluetoothAddressStr (component Bluetooth_EGBT)
**     Description :
**         Queries the Bluetooth address
**     Parameters  :
**         NAME            - DESCRIPTION
**       * buf             - Pointer to buffer where to store the string
**         bufSize         - Size of the buffer in bytes.
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte BT1_btQueryBluetoothAddressStr(byte *buf, size_t bufSize)
{
  /* 5: Query device bluetooth address: "AT+ADDR?\r\n" ==> "+ADDR:<nn:uu:ll>\r\nOK\r\n" */
  return BT1_QueryString((unsigned char*)"AT+ADDR?", (unsigned char*)"+ADDR:", buf, bufSize);
}

/*
** ===================================================================
**     Method      :  BT1_btQueryDeviceName (component Bluetooth_EGBT)
**     Description :
**         Queries the device name
**     Parameters  :
**         NAME            - DESCRIPTION
**       * buf             - Pointer to buffer where to store the string
**         bufSize         - Size of the buffer in bytes.
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte BT1_btQueryDeviceName(byte *buf, size_t bufSize)
{
  /* 6: Query name: "AT+NAME?\r\n" ==> "+NAME:<name>\r\nOK\r\n" */
  return BT1_QueryString((unsigned char*)"AT+NAME?", (unsigned char*)"+NAME:", buf, bufSize);
}

/*
** ===================================================================
**     Method      :  BT1_btSetDeviceName (component Bluetooth_EGBT)
**     Description :
**         Sets the device name
**     Parameters  :
**         NAME            - DESCRIPTION
**       * name            - Pointer to new device name
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte BT1_btSetDeviceName(byte *name)
{
  /* 6: Set name: "AT+NAME<name>" ==> "OKsetname" */
  unsigned char buf[sizeof("AT+NAME")+BT1_MAX_DEVICE_NAME_SIZE];
  unsigned char rxBuf[sizeof("OKsetname")+1];

  if (UTIL1_strlen((char*)name)>BT1_MAX_DEVICE_NAME_SIZE) {
    return ERR_FAILED; /* name too long */
  }
  UTIL1_strcpy(buf, sizeof(buf), (unsigned char*)"AT+NAME");
  UTIL1_strcat(buf, sizeof(buf), name);
  return BT1_StdCmd(buf, rxBuf, sizeof(rxBuf), (unsigned char*)"OKsetname");
}

/*
** ===================================================================
**     Method      :  BT1_btQueryRemoteBluetoothDeviceName (component Bluetooth_EGBT)
**     Description :
**         Queries the remote Bluetooth device name
**     Parameters  :
**         NAME            - DESCRIPTION
**       * buf             - Pointer to buffer where to store the string
**         bufSize         - Size of the buffer in bytes.
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte BT1_btQueryRemoteBluetoothDeviceName(byte *buf, size_t bufSize)
{
  /* 7: Query device bluetooth address: "AT+RNAME?<addr>\r\n" ==> "+NAME:<name>\r\nOK\r\n" */
  /* Example: Query remote Bluetooth device having address 00:02:72:0A:3C:7F
     Bluetooth address in NA:UAP:LAP format = 0002:72:0A3C7F
     From Host controller:
     AT+RNAME?0002,72,0A3C7FÉ
     response if remote device name is “HC-05”: "+NAME:HC-05\r\nOK\r\n"
     response if remote device name is unresolved: "FAIL\r\n"
   */
  return BT1_QueryString((unsigned char*)"AT+RNAME?", (unsigned char*)"+NAME:", buf, bufSize);
}

/*
** ===================================================================
**     Method      :  BT1_btQueryRole (component Bluetooth_EGBT)
**     Description :
**         Returns the current device role
**     Parameters  :
**         NAME            - DESCRIPTION
**       * role            - Pointer to character which will hold the
**                           role ('0' for slave, '1' for master or '2'
**                           for slave-loop)
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte BT1_btQueryRole(byte *role)
{
  unsigned char buf[2];
  /* 8: Query device role: "AT+ROLE?\r\n" ==> "+ROLE:<role>\r\nOK\r\n" */
  /* <role>: '0': slave, '1': master, '2': slave-loop */
  if (BT1_QueryString((unsigned char*)"AT+ROLE?", (unsigned char*)"+ROLE:", buf, sizeof(buf)) != ERR_OK) {
    return ERR_FAILED;
  }
  if (buf[0] < '0' || buf[0] > '2') {
    return ERR_FAILED;
  }
  *role = buf[0];
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  BT1_btSetRole (component Bluetooth_EGBT)
**     Description :
**         Sets the device role
**     Parameters  :
**         NAME            - DESCRIPTION
**         role            - Character  with the role ('0' for slave,
**                           '1' for master or '2' for slave-loop)
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte BT1_btSetRole(byte role)
{
  /* 8: Set device role: "AT+ROLE=<role>\r\n" ==> "OK\r\n" */
  /* role must be '0' (slave), '1' (master) or '2' (slave-loop) */
  unsigned char buf[sizeof("AT+ROLE=0\r\n")];

  if (role<'0' || role>'2') {
    return ERR_FAILED; /* not a valid role */
  }

  UTIL1_strcpy(buf, sizeof(buf), (unsigned char*)"AT+ROLE=");
  UTIL1_chcat(buf, sizeof(buf), role);
  UTIL1_strcat(buf, sizeof(buf), (unsigned char*)"\r\n");

  return BT1_StdOKCmd(buf);
}

/*
** ===================================================================
**     Method      :  BT1_btQueryCoDStr (component Bluetooth_EGBT)
**     Description :
**         Queries the Class of Device
**     Parameters  :
**         NAME            - DESCRIPTION
**       * buf             - Pointer to buffer where to store the string
**         bufSize         - Size of the buffer in bytes.
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte BT1_btQueryCoDStr(byte *buf, size_t bufSize)
{
  /* 9: Query device CoD (Class of Device): "AT+CLASS?\r\n" ==> "+CLASS:<class>\r\nOK\r\n" */
  return BT1_QueryString((unsigned char*)"AT+CLASS?", (unsigned char*)"+CLASS:", buf, bufSize);
}

/*
** ===================================================================
**     Method      :  BT1_btSetCoDStr (component Bluetooth_EGBT)
**     Description :
**         Sets the Class of Device string
**     Parameters  :
**         NAME            - DESCRIPTION
**       * classStr        - Pointer to new class of device
**                           string
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte BT1_btSetCoDStr(byte *classStr)
{
  /* 9: Set device role: "AT+CLASS=<class>\r\n" ==> "OK\r\n" */
  unsigned char buf[sizeof("AT+CLASS=000000000\r\n")];

  UTIL1_strcpy(buf, sizeof(buf), (unsigned char*)"AT+CLASS=");
  UTIL1_strcat(buf, sizeof(buf), classStr);
  UTIL1_strcat(buf, sizeof(buf), (unsigned char*)"\r\n");

  return BT1_StdOKCmd(buf);
}

/*
** ===================================================================
**     Method      :  BT1_btQueryIACStr (component Bluetooth_EGBT)
**     Description :
**         Queries the Inquire Access Code (IAC)
**     Parameters  :
**         NAME            - DESCRIPTION
**       * buf             - Pointer to buffer where to store the string
**         bufSize         - Size of the buffer in bytes.
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte BT1_btQueryIACStr(byte *buf, size_t bufSize)
{
  /* 10: Set Inquire Access Code (IAC): "AT+IAC?\r\n" ==> "+IAC:<iac>\r\nOK\r\n" */
  return BT1_QueryString((unsigned char*)"AT+IAC?", (unsigned char*)"+IAC:", buf, bufSize);
}

/*
** ===================================================================
**     Method      :  BT1_btSetIACStr (component Bluetooth_EGBT)
**     Description :
**         Sets the Inquire Access Code string
**     Parameters  :
**         NAME            - DESCRIPTION
**       * iac             - Pointer to new Inquire Access Code string
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte BT1_btSetIACStr(byte *iac)
{
  /* 10: Set Inquiry Access Code (IAC): "AT+IAC=<iac>\r\n" ==> "OK\r\n" */
  unsigned char buf[sizeof("AT+IAC=009e8b33\r\n")];

  UTIL1_strcpy(buf, sizeof(buf), (unsigned char*)"AT+IAC=");
  UTIL1_strcat(buf, sizeof(buf), iac);
  UTIL1_strcat(buf, sizeof(buf), (unsigned char*)"\r\n");
  return BT1_StdOKCmd(buf);
}

/*
** ===================================================================
**     Method      :  BT1_btQueryIAMStr (component Bluetooth_EGBT)
**     Description :
**         Queries the Inquire Access Mode (IAM)
**     Parameters  :
**         NAME            - DESCRIPTION
**       * buf             - Pointer to buffer where to store the string
**         bufSize         - Size of the buffer in bytes.
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte BT1_btQueryIAMStr(byte *buf, size_t bufSize)
{
  /* 11: Set Inquire Access Mode (IAM): "AT+INQM?\r\n" ==> "+INQM:<inq1,inq2,inq3>\r\nOK\r\n" */
  return BT1_QueryString((unsigned char*)"AT+INQM?", (unsigned char*)"+INQM:", buf, bufSize);
}

/*
** ===================================================================
**     Method      :  BT1_btSetIAMStr (component Bluetooth_EGBT)
**     Description :
**         Sets the Inquire Access Mode string
**     Parameters  :
**         NAME            - DESCRIPTION
**       * iam             - Pointer to new Inquire Access Mode string
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte BT1_btSetIAMStr(byte *iam)
{
  /* 11: Set Inquiry Access Mode (IAM): "AT+INQM=<inq1,inq2,inq3>\r\n" ==> "OK\r\n" */
  unsigned char buf[sizeof("AT+INQM=0,32000,48\r\n")];

  UTIL1_strcpy(buf, sizeof(buf), (unsigned char*)"AT+INQM=");
  UTIL1_strcat(buf, sizeof(buf), iam);
  UTIL1_strcat(buf, sizeof(buf), (unsigned char*)"\r\n");
  return BT1_StdOKCmd(buf);
}

/*
** ===================================================================
**     Method      :  BT1_btQueryPairingPasskey (component Bluetooth_EGBT)
**     Description :
**         Queries the Pairing Passkey
**     Parameters  :
**         NAME            - DESCRIPTION
**       * buf             - Pointer to buffer where to store the string
**         bufSize         - Size of the buffer in bytes.
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte BT1_btQueryPairingPasskey(byte *buf, size_t bufSize)
{
  /* 12: Query pairing pass key: "AT+PSWD?\r\n" ==> "+PSWD:<password>\r\nOK\r\n" */
  return BT1_QueryString((unsigned char*)"AT+PSWD?", (unsigned char*)"+PSWD:", buf, bufSize);
}

/*
** ===================================================================
**     Method      :  BT1_btSetPairingPasskey (component Bluetooth_EGBT)
**     Description :
**         Sets the pairing passkey
**     Parameters  :
**         NAME            - DESCRIPTION
**       * pwd             - Pointer to new pairing passkey
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte BT1_btSetPairingPasskey(byte *pwd)
{
  /* 12: Set paring pass key: "AT+PSWD=<pwd>\r\n" ==> "OK\r\n" */
  unsigned char buf[sizeof("AT+PSWD=1234567890123456\r\n")];

  if (UTIL1_strlen((char*)pwd)>16) { /* check for password size */
    return ERR_FAILED;
  }
  UTIL1_strcpy(buf, sizeof(buf), (unsigned char*)"AT+PSWD=");
  UTIL1_strcat(buf, sizeof(buf), pwd);
  UTIL1_strcat(buf, sizeof(buf), (unsigned char*)"\r\n");
  return BT1_StdOKCmd(buf);
}

/*
** ===================================================================
**     Method      :  BT1_btQueryUARTParametersStr (component Bluetooth_EGBT)
**     Description :
**         Queries the UART parameters
**     Parameters  :
**         NAME            - DESCRIPTION
**       * buf             - Pointer to buffer where to store the string
**         bufSize         - Size of the buffer in bytes.
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte BT1_btQueryUARTParametersStr(byte *buf, size_t bufSize)
{
  /* 13: Query UART Parameters: "AT+UART?\r\n" ==> "+UART:<baud,stop,parity>\r\nOK\r\n" */
  return BT1_QueryString((unsigned char*)"AT+UART?", (unsigned char*)"+UART:", buf, bufSize);
}

/*
** ===================================================================
**     Method      :  BT1_btSetUARTParameterStr (component Bluetooth_EGBT)
**     Description :
**         Sets the UART parameter.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * param           - Pointer to new UART parameter string
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte BT1_btSetUARTParameterStr(byte *param)
{
  /* 13: Set UART Parameters: "AT+UART=<baud,stop,parity>\r\n" ==> "OK\r\n" */
  unsigned char buf[sizeof("AT+UART=1382400,1,0\r\n")];

  if (UTIL1_strlen((char*)param)>sizeof("1382400,1,0")) { /* check for parameter size */
    return ERR_FAILED;
  }
  UTIL1_strcpy(buf, sizeof(buf), (unsigned char*)"AT+UART=");
  UTIL1_strcat(buf, sizeof(buf), param);
  UTIL1_strcat(buf, sizeof(buf), (unsigned char*)"\r\n");
  return BT1_StdOKCmd(buf);
}

/*
** ===================================================================
**     Method      :  BT1_btSetBaud (component Bluetooth_EGBT)
**     Description :
**         Sets the baud rate of the device.
**     Parameters  :
**         NAME            - DESCRIPTION
**         baud            - 1200, 2400, 4800, 9600, 19200, 38400,
**                           57600, 115200
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte BT1_btSetBaud(dword baud)
{
  unsigned char buf[sizeof("AT+UART=1382400,1,0\r\n")];

  UTIL1_strcpy(buf, sizeof(buf), (unsigned char*)"AT+UART=");
  UTIL1_strcatNum32u(buf, sizeof(buf), baud); /* append baud number */
  UTIL1_strcat(buf, sizeof(buf), (unsigned char*)",1,0\r\n");
  return BT1_StdOKCmd(buf);
}

/*
** ===================================================================
**     Method      :  BT1_btQueryConnectionMethod (component Bluetooth_EGBT)
**     Description :
**         Returns the connection method
**     Parameters  :
**         NAME            - DESCRIPTION
**       * method          - Pointer to character which will hold
**                           the mode: '0' (specified device only,
**                           default), '1' (can connect to any device),
**                           '2' (test mode)
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte BT1_btQueryConnectionMethod(byte *method)
{
	unsigned char buf[2];

  /* 14: Query connection method: "AT+CMODE?\r\n" ==> "+CMOD:<mode>\r\nOK\r\n" */
  /* NOTE: the documentation says the device should respond with "+CMODE", but actually it responds with "+CMOD"! */
  /* where <mode>
	 0 - Connect to a specified Bluetooth device only (default).
     See related command Command 15.
     1 - Can connect with any other Bluetooth device.
     2 - Test mode
  */
  if (BT1_QueryString((unsigned char*)"AT+CMODE?", (unsigned char*)"+CMOD:", buf, sizeof(buf)) != ERR_OK) {
    return ERR_FAILED;
  }
  if (buf[0] < '0' || buf[0] > '2') {
    return ERR_FAILED;
  }

  *method = buf[0];
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  BT1_btSetConnectionMethod (component Bluetooth_EGBT)
**     Description :
**         Sets the device connection method
**     Parameters  :
**         NAME            - DESCRIPTION
**         method          - '0' (specified device only, default),
**                           '1' (can connect to any device), '2' (test
**                           mode)
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte BT1_btSetConnectionMethod(byte method)
{
  /* 14: Set connection method: "AT+CMODE=<mode>\r\n" ==> "OK\r\n" */
  /* role must be '0' (connect to specified device), '1' (connect to any device) or '2' (test mode) */
  /* where <mode>
     0 - Connect to a specified Bluetooth device only (default).
     See related command Command 15.
     1 - Can connect with any other Bluetooth device.
     2 - Test mode
  */
  unsigned char buf[sizeof("AT+CMODE=0\r\n")];

  if (method<'0' || method>'2') {
    return ERR_FAILED; /* not a valid method */
  }

  UTIL1_strcpy(buf, sizeof(buf), (unsigned char*)"AT+CMODE=");
  UTIL1_chcat(buf, sizeof(buf), method);
  UTIL1_strcat(buf, sizeof(buf), (unsigned char*)"\r\n");

  return BT1_StdOKCmd(buf);
}

/*
** ===================================================================
**     Method      :  BT1_btQueryBindingBluetoothAddress (component Bluetooth_EGBT)
**     Description :
**         Queries the Binding Bluetooth Address
**     Parameters  :
**         NAME            - DESCRIPTION
**       * buf             - Pointer to buffer where to store the string
**         bufSize         - Size of the buffer in bytes.
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte BT1_btQueryBindingBluetoothAddress(byte *buf, size_t bufSize)
{
  /* 15: Query Binding Bluetooth Address: "AT+BIND?\r\n" ==> "+BIND:<addr>\r\nOK\r\n"
     where <addr> = 48 bit bluetooth address in NAP,UAP,LAP format
     Example: Bind with Bluetooth device having address = 00:02:72:0A:3C:7F
     Bluetooth address in NA,UAP,LAP format = 0002,72,0A3C7F
  */
  return BT1_QueryString((unsigned char*)"AT+BIND?", (unsigned char*)"+BIND:", buf, bufSize);
}

/*
** ===================================================================
**     Method      :  BT1_btSetBindingBluetoothStr (component Bluetooth_EGBT)
**     Description :
**         Sets the Binding Bluetooth Address.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * addr            - Pointer to new bluetooth address sting
**                           in NAP,UAP,LAP format.
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte BT1_btSetBindingBluetoothStr(byte *addr)
{
  /* 15: Set Binding Bluetooth Address: "AT+BIND=<addr>\r\n" ==> "OK\r\n"
     where <addr> = 48 bit bluetooth address in NAP,UAP,LAP format
     Example: Bind with Bluetooth device having address = 00:02:72:0A:3C:7F
     Bluetooth address in NA,UAP,LAP format = 0002,72,0A3C7F
  */
  unsigned char buf[sizeof("AT+BIND=0000,00,000000\r\n")];

  UTIL1_strcpy(buf, sizeof(buf), (unsigned char*)"AT+BIND=");
  UTIL1_strcat(buf, sizeof(buf), addr);
  UTIL1_strcat(buf, sizeof(buf), (unsigned char*)"\r\n");
  return BT1_StdOKCmd(buf);
}

/*
** ===================================================================
**     Method      :  BT1_btQueryLEDOutputPolarityStr (component Bluetooth_EGBT)
**     Description :
**         Returns the LED output polarity
**     Parameters  :
**         NAME            - DESCRIPTION
**       * buf             - Pointer to buffer where to store the LED
**                           output polarity. LED polarity in <led1,
**                           <led2> format. 0 for LED output active low,
**                           1 for LED output active high (default)
**         bufSize         - Size of the buffer in bytes.
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte BT1_btQueryLEDOutputPolarityStr(byte *buf, size_t bufSize)
{
  /* 16: Query LED output polarity: "AT+POLAR?\r\n" ==> "+POLAR:<led1>,<led2>\r\nOK\r\n"
     where <led1> = LED1 (pin 31) Polarity
     0 - LED1 output active low
     1 - LED1 output active high (default)
     <led2> = LED2 (pin 32) Polarity
     0 - LED2 output active low
     1 - LED2 output active high (default)
  */
  return BT1_QueryString((unsigned char*)"AT+POLAR?", (unsigned char*)"+POLAR:", buf, bufSize);
}

/*
** ===================================================================
**     Method      :  BT1_btSetLEDOutputPolarityStr (component Bluetooth_EGBT)
**     Description :
**         Sets the LED output polarity
**     Parameters  :
**         NAME            - DESCRIPTION
**       * ledPolarityStr  - Pointer to string
**                           with the LED polarity in <led1,<led2>
**                           format. 0 for LED output active low, 1 for
**                           LED output active high (default)
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte BT1_btSetLEDOutputPolarityStr(byte *ledPolarityStr)
{
  /* 16: Query LED output polarity: "AT+POLAR=<led1>,<led2>\r\n" ==> "OK\r\n"
     where <led1> = LED1 (pin 31) Polarity
     0 - LED1 output active low
     1 - LED1 output active high (default)
     <led2> = LED2 (pin 32) Polarity
     0 - LED2 output active low
     1 - LED2 output active high (default)
  */
  unsigned char buf[sizeof("AT+POLAR=0,0\r\n")];

  UTIL1_strcpy(buf, sizeof(buf), (unsigned char*)"AT+POLAR=");
  UTIL1_strcat(buf, sizeof(buf), ledPolarityStr);
  UTIL1_strcat(buf, sizeof(buf), (unsigned char*)"\r\n");

  return BT1_StdOKCmd(buf);
}

/*
** ===================================================================
**     Method      :  BT1_btSetUserPinIO (component Bluetooth_EGBT)
**     Description :
**         Sets or clears a user I/O pin
**     Parameters  :
**         NAME            - DESCRIPTION
**         portNumber      - Portnumer, available port
**                           numbers are 2, 3, 4, 5, 6, 7 and 10.
**         on              - If port is on (logic high) or off (logic
**                           low)
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte BT1_btSetUserPinIO(byte portNumber, bool on)
{
  /* 17: Set/Reset a User I/O pin: "AT+PIO=<pn>,<value>\r\n" ==> "OK\r\n"
     where <pn> = port number. Available port are as follows
     2 - PIO2
     3 - PIO3
     4 - PIO4
     5 - PIO5
     6 - PIO6
     7 - PIO7
     10 - PIO10
     <value>
     0 - Logic Low
     1 - Logic High
  */
  unsigned char buf[sizeof("AT+PIO=0,0\r\n")];

  if (portNumber<2 || portNumber==8 || portNumber==9 || portNumber>10) {
    return ERR_FAILED; /* wrong port number */
  }

  UTIL1_strcpy(buf, sizeof(buf), (unsigned char*)"AT+PIO=");
  UTIL1_chcat(buf, sizeof(buf), (unsigned char)('0'+portNumber));
  UTIL1_chcat(buf, sizeof(buf), ',');
  UTIL1_chcat(buf, sizeof(buf), on?'1':'0');
  UTIL1_strcat(buf, sizeof(buf), (unsigned char*)"\r\n");

  return BT1_StdOKCmd(buf);
}

/*
** ===================================================================
**     Method      :  BT1_btSetMultipleUserIOPins (component Bluetooth_EGBT)
**     Description :
**         Sets or clears multiple User I/O pins
**     Parameters  :
**         NAME            - DESCRIPTION
**         mask            - 12 Bit mask (0 for clear/low level, 1
**                           for set/high level). Mapping to pins: 
**                           (x)(10)(x)(x)(7)(6)(5)(4)(3)(2)(x)(x) with
**                           (x) as 'don not care'.
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte BT1_btSetMultipleUserIOPins(word mask)
{
  /* 18: Set/Reset multiple User I/O pin: "AT+MPIO=<iomap>\r\n" ==> "OK\r\n"
     where <iomap> is a 12bit number presented in hexadecimal
     bit 2 - PIO2
     bit 3 - PIO3
     bit 4 - PIO4
     bit 5 - PIO5
     bit 6 - PIO6
     bit 7 - PIO7
     bit 10 - PIO10
     <value>
     0 - Logic Low
     1 - Logic High
  */
  unsigned char buf[sizeof("AT+MPIO=000\r\n")];

  mask &= 0x4FC; /* mask out the used bits */
  UTIL1_strcpy(buf, sizeof(buf), (unsigned char*)"AT+MPIO=");
  UTIL1_strcatNum16Hex(buf, sizeof(buf), mask);
  UTIL1_strcat(buf, sizeof(buf), (unsigned char*)"\r\n");

  return BT1_StdOKCmd(buf);
}

/*
** ===================================================================
**     Method      :  BT1_btQueryMultipleUserIOPinsStr (component Bluetooth_EGBT)
**     Description :
**         Queries multiple User I/O pins
**     Parameters  :
**         NAME            - DESCRIPTION
**       * buf             - Pointer to buffer where to store the
**                           return string
**         bufSize         - Size of the buffer in bytes.
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte BT1_btQueryMultipleUserIOPinsStr(byte *buf, size_t bufSize)
{
  /* 19: Query User Pin I/O: "AT+MPIO?\r\n" ==> "+MPIO:<iomap>\r\nOK\r\n"
     where <iomap> is a 12bit number presented in hexadecimal
     bit 2 - PIO2
     bit 3 - PIO3
     bit 4 - PIO4
     bit 5 - PIO5
     bit 6 - PIO6
     bit 7 - PIO7
     bit 10 - PIO10
     <value>
     0 - Logic Low
     1 - Logic High
  */
  return BT1_QueryString((unsigned char*)"AT+MPIO?", (unsigned char*)"+MPIO:", buf, bufSize);
}

/*
** ===================================================================
**     Method      :  BT1_btQueryMultipleUserIOPins (component Bluetooth_EGBT)
**     Description :
**         Queries multiple User I/O pins
**     Parameters  :
**         NAME            - DESCRIPTION
**       * mask            - Pointer to 12 Bit mask (0 for clear/low
**                           level, 1 for set/high level). Mapping to
**                           pins: 
**                           (x)(10)(x)(x)(7)(6)(5)(4)(3)(2)(x)(x) with
**                           (x) as 'don not care'.
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte BT1_btQueryMultipleUserIOPins(word *mask)
{
  /* 19: Query User Pin I/O: "AT+MPIO?\r\n" ==> "+MPIO:<iomap>\r\nOK\r\n"
      where
      <iomap> is a 12bit number presented in hexadecimal
      bit 2 - PIO2
      bit 3 - PIO3
      bit 4 - PIO4
      bit 5 - PIO5
      bit 6 - PIO6
      bit 7 - PIO7
      bit 10 - PIO10
      <value>
      0 - Logic Low
      1 - Logic High
  */
  unsigned char buf[sizeof("0xAAA")];
  const unsigned char *p;

  UTIL1_strcpy(buf, sizeof(buf), (unsigned char*)"0x");
  if (BT1_btQueryMultipleUserIOPinsStr(buf+2, sizeof(buf)-2)!=ERR_OK) {
    *mask = 0;
    return ERR_FAILED;
  }
  p = &buf[0];
  return UTIL1_ScanHex16uNumber(&p, mask);
}

/*
** ===================================================================
**     Method      :  BT1_btQueryScanningParametersStr (component Bluetooth_EGBT)
**     Description :
**         Query scanning parameters
**     Parameters  :
**         NAME            - DESCRIPTION
**       * buf             - Pointer to buffer where to store the
**                           parameters.
**         bufSize         - Size of the buffer in bytes.
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte BT1_btQueryScanningParametersStr(byte *buf, size_t bufSize)
{
  /* 20: Query Scanning Parameters: "AT+IPSCAN?\r\n" ==> "+IPSCAN:<int>,<dur>,<pint>,<pdur>\r\nOK\r\n"
      where
      <int> = inquire scan time interval
      1024 - default
      <dur> = inquire scan time duration
      512 - default
      <pint> = page scan time interval
      1024 - default
      <pdur> = page scan time duration
      512 - default
  */
  return BT1_QueryString((unsigned char*)"AT+IPSCAN?", (unsigned char*)"+IPSCAN:", buf, bufSize);
}

/*
** ===================================================================
**     Method      :  BT1_btSetScanningParameterStr (component Bluetooth_EGBT)
**     Description :
**         Sets the scanning parameters
**     Parameters  :
**         NAME            - DESCRIPTION
**       * param           - Pointer to string with the parameters.
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte BT1_btSetScanningParameterStr(byte *param)
{
  /* 20: Set Scanning Parameters: "AT+IPSCAN=<int>,<dur>,<pint>,<pdur>\r\n" ==> "OK\r\n"
      where
      <int> = inquire scan time interval
      1024 - default
      <dur> = inquire scan time duration
      512 - default
      <pint> = page scan time interval
      1024 - default
      <pdur> = page scan time duration
      512 - default
  */
  unsigned char buf[sizeof("AT+IPSCAN=32000,32000,32000,32000\r\n")];

  UTIL1_strcpy(buf, sizeof(buf), (unsigned char*)"AT+IPSCAN=");
  UTIL1_strcat(buf, sizeof(buf), param);
  UTIL1_strcat(buf, sizeof(buf), (unsigned char*)"\r\n");

  return BT1_StdOKCmd(buf);
}

/*
** ===================================================================
**     Method      :  BT1_btQuerySNIFFParametersStr (component Bluetooth_EGBT)
**     Description :
**         Query SNIFF Energy Savings Parameters
**     Parameters  :
**         NAME            - DESCRIPTION
**       * buf             - Pointer to buffer where to store the
**                           parameters.
**         bufSize         - Size of the buffer in bytes.
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte BT1_btQuerySNIFFParametersStr(byte *buf, size_t bufSize)
{
  /* 21: Query SNIFF Energy Savings Parameters: "AT+SNIFF?\r\n" ==> "+SNIFF:<tmax>,<tmin>,<retry>,<timeout>\r\nOK\r\n"
     where <tmax> = maximum time
     0 - default
     <tmin> = minimum time
     0 - default
     <retry> = retry time
     0 - default
     <timeout> = timeout
     0 - default
     All parameters must be represented with decimal integer value.
   */
  return BT1_QueryString((unsigned char*)"AT+SNIFF?", (unsigned char*)"+SNIFF:", buf, bufSize);
}

/*
** ===================================================================
**     Method      :  BT1_btSetSNIFFParameterStr (component Bluetooth_EGBT)
**     Description :
**         Set SNIFF Energy Saving Parameters
**     Parameters  :
**         NAME            - DESCRIPTION
**       * param           - Pointer to string with the parameters.
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte BT1_btSetSNIFFParameterStr(byte *param)
{
  /* 20: Set SNIFF Energy Savings Parameters: "AT+SNIFF=<tmax>,<tmin>,<retry>,<timeout>\r\n" ==> "OK\r\n"
     where <tmax> = maximum time
     0 - default
     <tmin> = minimum time
     0 - default
     <retry> = retry time
     0 - default
     <timeout> = timeout
     0 - default
     All parameters must be represented with decimal integer value.
  */
  unsigned char buf[sizeof("AT+SNIFF=32000,32000,32000,32000,32000\r\n")];

  UTIL1_strcpy(buf, sizeof(buf), (unsigned char*)"AT+SNIFF=");
  UTIL1_strcat(buf, sizeof(buf), param);
  UTIL1_strcat(buf, sizeof(buf), (unsigned char*)"\r\n");

  return BT1_StdOKCmd(buf);
}

/*
** ===================================================================
**     Method      :  BT1_btQuerySecurityEncryptionModesStr (component Bluetooth_EGBT)
**     Description :
**         Query Security & Encryption Modes
**     Parameters  :
**         NAME            - DESCRIPTION
**       * buf             - Pointer to buffer where to store the
**                           security and encryption modes, in 'mode',
**                           'encrypt' format.
**                           'mode' = Security Mode
**                           0 - sec_mode_off (default)
**                           1 - sec_mode1_non-secure
**                           2 - sec_mode2-service
**                           3 - sec_mode3_link
**                           4 - sec_mode_unknown
**                           'encrypt' = encryption mode
**                           0 - hci_enc_mode_off (default)
**                           1 - hci_enc_mode_pt_to_pt
**                           2 - hci_enc_mode_pt_to_pt_and_bcast
**         bufSize         - Size of the buffer in bytes.
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte BT1_btQuerySecurityEncryptionModesStr(byte *buf, size_t bufSize)
{
  /* 22: Query Security and Encryption Modes: "AT+SENM?\r\n" ==> "+SENM:<mode>,<encrypt>\r\nOK\r\n"
      where <mode> = Security Mode
      0 - sec_mode_off (default)
      1 - sec_mode1_non-secure
      2 - sec_mode2-service
      3 - sec_mode3_link
      4 - sec_mode_unknown
      <encrypt> = encryption mode
      0 - hci_enc_mode_off (default)
      1 - hci_enc_mode_pt_to_pt
      2 - hci_enc_mode_pt_to_pt_and_bcast
  */
  return BT1_QueryString((unsigned char*)"AT+SENM?", (unsigned char*)"+SENM:", buf, bufSize);
}

/*
** ===================================================================
**     Method      :  BT1_btSetSecurityEncryptionModesStr (component Bluetooth_EGBT)
**     Description :
**         Set Security & Encryption Modes
**     Parameters  :
**         NAME            - DESCRIPTION
**       * modes           - Pointer to string with the security
**                           and encryption modes, in 'mode', 'encrypt'
**                           format.
**                           'mode' = Security Mode
**                           0 - sec_mode_off (default)
**                           1 - sec_mode1_non-secure
**                           2 - sec_mode2-service
**                           3 - sec_mode3_link
**                           4 - sec_mode_unknown
**                           'encrypt' = encryption mode
**                           0 - hci_enc_mode_off (default)
**                           1 - hci_enc_mode_pt_to_pt
**                           2 - hci_enc_mode_pt_to_pt_and_bcast
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte BT1_btSetSecurityEncryptionModesStr(byte *modes)
{
  /* 22: Set Security and Encryption Modes: "AT+SENM=<mode>,<encrypt>\r\n" ==> "OK\r\n"
      where <mode> = Security Mode
      0 - sec_mode_off (default)
      1 - sec_mode1_non-secure
      2 - sec_mode2-service
      3 - sec_mode3_link
      4 - sec_mode_unknown
      <encrypt> = encryption mode
      0 - hci_enc_mode_off (default)
      1 - hci_enc_mode_pt_to_pt
      2 - hci_enc_mode_pt_to_pt_and_bcast
  */
  unsigned char buf[sizeof("AT+SENM=0,0\r\n")];

  UTIL1_strcpy(buf, sizeof(buf), (unsigned char*)"AT+SENM=");
  UTIL1_strcat(buf, sizeof(buf), modes);
  UTIL1_strcat(buf, sizeof(buf), (unsigned char*)"\r\n");

  return BT1_StdOKCmd(buf);
}

/*
** ===================================================================
**     Method      :  BT1_btDeleteAuthenticatedDeviceFromListStr (component Bluetooth_EGBT)
**     Description :
**         Deletes an authenticated device from the list
**     Parameters  :
**         NAME            - DESCRIPTION
**       * addrString      - Pointer to address in NAP,
**                           UAP,LAP format.
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte BT1_btDeleteAuthenticatedDeviceFromListStr(byte *addrString)
{
  /* 23: Delete Authenticated Device from List: "AT+RMSAD=<addr>\r\n" ==> "OK\r\n"
     where
     <addr> = 48 bit bluetooth address in NAP,UAP,LAP format
     Example: Remove from Authenticated Device list a Bluetooth
     device having address = 00:02:72:0A:3C:7F
     Bluetooth address in NA,UAP,LAP format = 0002,72,0A3C7F
  */
  unsigned char buf[sizeof("AT+RMSAD=0002,72,0A3C7F\r\n")];

  UTIL1_strcpy(buf, sizeof(buf), (unsigned char*)"AT+REMSAD=");
  UTIL1_strcat(buf, sizeof(buf), addrString);
  UTIL1_strcat(buf, sizeof(buf), (unsigned char*)"\r\n");

  return BT1_StdOKCmd(buf);
}

/*
** ===================================================================
**     Method      :  BT1_btFindDeviceFromAuthenticatedDeviceListStr (component Bluetooth_EGBT)
**     Description :
**         Find Device from Authenticated Device List
**     Parameters  :
**         NAME            - DESCRIPTION
**       * addrString      - Pointer to address in NAP,
**                           UAP,LAP format
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte BT1_btFindDeviceFromAuthenticatedDeviceListStr(byte *addrString)
{
  /* 24: Find Device from Authenticated Device List: "AT+FSAD=<addr>\r\n" ==> "OK\r\n"
     where <addr> = 48 bit bluetooth address in NAP,UAP,LAP format
     Note: AT+FSAD returns a FAIL response if device is not
     in the authenticated list
   */
  unsigned char buf[sizeof("AT+FSAD=0002,72,0A3C7F\r\n")];

  UTIL1_strcpy(buf, sizeof(buf), (unsigned char*)"AT+FSAD=");
  UTIL1_strcat(buf, sizeof(buf), addrString);
  UTIL1_strcat(buf, sizeof(buf), (unsigned char*)"\r\n");

  return BT1_StdOKCmd(buf);
}

/*
** ===================================================================
**     Method      :  BT1_btQueryTotalNumberOfDeviceFromAuthenticationListStr (component Bluetooth_EGBT)
**     Description :
**         
**     Parameters  :
**         NAME            - DESCRIPTION
**       * buf             - Pointer to where buffer where to store the
**                           result string
**         bufSize         - Size of the buffer in bytes.
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte BT1_btQueryTotalNumberOfDeviceFromAuthenticationListStr(byte *buf, size_t bufSize)
{
  /* 25: Query Total Number of Device from Authenticated Device List: "AT+ADCN?\r\n" ==> "+ADCN:<total>\r\nOK\r\n"
     where <total> = total number of devices in the authenticated device list
   */
  return BT1_QueryString((unsigned char*)"AT+ADCN?", (unsigned char*)"+ADCN:", buf, bufSize);
}

/*
** ===================================================================
**     Method      :  BT1_btQueryTotalNumberOfDeviceFromAuthenticationList (component Bluetooth_EGBT)
**     Description :
**         
**     Parameters  :
**         NAME            - DESCRIPTION
**       * nofDevices      - Pointer to where to return
**                           the number of authenticated devices in list.
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte BT1_btQueryTotalNumberOfDeviceFromAuthenticationList(byte *nofDevices)
{
  /* 25: Query Total Number of Device from Authenticated Device List: "AT+ADCN?\r\n" ==> "+ADCN:<total>\r\nOK\r\n"
     where <total> = total number of devices in the authenticated device list
   */
  unsigned char buf[sizeof("1024")];
  const unsigned char *p;

  if (BT1_btQueryTotalNumberOfDeviceFromAuthenticationListStr(buf, sizeof(buf)) != ERR_OK) {
    return ERR_FAILED;
  }
  p = &buf[0];
  return UTIL1_ScanDecimal8uNumber(&p, nofDevices);
}

/*
** ===================================================================
**     Method      :  BT1_btQueryMostRecentlyUsedAuthenticatedDevice (component Bluetooth_EGBT)
**     Description :
**         Query Most Recently Used Authenticated Device
**     Parameters  :
**         NAME            - DESCRIPTION
**       * buf             - Pointer to buffer where to the 48bit
**                           address string in NAP:UAP:LAP format.
**         bufSize         - Size of the buffer in bytes.
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte BT1_btQueryMostRecentlyUsedAuthenticatedDevice(byte *buf, size_t bufSize)
{
  /* 26: Query Most Recently Used Authenticated Device: "AT+MRAD?\r\n" ==> "+MRAD:<tmax>,<tmin>,<retry>,<timeout>\r\nOK\r\n"
      where
      <addr> = 48 bit bluetooth address in NAP:UAP:LAP format
  */
  return BT1_QueryString((unsigned char*)"AT+MRAD?", (unsigned char*)"+MRAD:", buf, bufSize);
}

/*
** ===================================================================
**     Method      :  BT1_btQueryCurrentStateOfDeviceStr (component Bluetooth_EGBT)
**     Description :
**         Query Current Status of the Device
**     Parameters  :
**         NAME            - DESCRIPTION
**       * buf             - Pointer to buffer where to the device
**                           status string, any one of the following:
**                           INITIALIZED
**                           READY
**                           PAIRABLE
**                           PAIRED
**                           INQUIRING
**                           CONNECTING
**                           CONNECTED
**                           DISCONNECTED
**                           UNKNOWN
**         bufSize         - Size of the buffer in bytes.
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte BT1_btQueryCurrentStateOfDeviceStr(byte *buf, size_t bufSize)
{
  /* 27: Query Current Status of the Device: "AT+STATE?\r\n" ==> "+STATE:<stat>\r\nOK\r\n"
      where
      <stat> = Current Status, any one of the following:
      INITIALIZED
      READY
      PAIRABLE
      PAIRED
      INQUIRING
      CONNECTING
      CONNECTED
      DISCONNECTED
      UNKNOWN
   */
  return BT1_QueryString((unsigned char*)"AT+STATE?", (unsigned char*)"+STATE:", buf, bufSize);
}

/*
** ===================================================================
**     Method      :  BT1_ParseCommand (component Bluetooth_EGBT)
**     Description :
**         Shell Command Line parser. Method is only available if Shell
**         is enabled in the component properties.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * cmd             - Pointer to command string
**       * handled         - Pointer to variable which tells if
**                           the command has been handled or not
**       * io              - Pointer to I/O structure
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte BT1_ParseCommand(const unsigned char* cmd, bool *handled, const CLS1_StdIOType *io)
{
  byte res = ERR_OK;

  if (UTIL1_strcmp((char*)cmd, CLS1_CMD_HELP) == 0
    || UTIL1_strcmp((char*)cmd, "BT1 help") == 0) {
    *handled = TRUE;
    return PrintHelp(io);
  } else if (UTIL1_strcmp((char*)cmd, CLS1_CMD_STATUS) == 0) {
    *handled = TRUE;
    res = PrintShortStatus(io); /* only print short status, as full status will fail if module is connected */
  } else if ((UTIL1_strcmp((char*)cmd, "BT1 status") == 0)) {
    *handled = TRUE;
    res = PrintLongStatus(io);
  } else if (UTIL1_strncmp((char*)cmd, "BT1 pin ", sizeof("BT1 pin ") - 1) == 0) {
    *handled = TRUE;
    res = BT1_btSetPairingPasskey((unsigned char*)cmd + sizeof("BT1 pin ") - 1);
  } else if (UTIL1_strncmp((char*)cmd, "BT1 name ", sizeof("BT1 name ") - 1) == 0) {
    *handled = TRUE;
    res = BT1_btSetDeviceName((unsigned char*)cmd + sizeof("BT1 name ") - 1);
  } else if (UTIL1_strncmp((char*)cmd, "BT1 baud ", sizeof("BT1 baud ") - 1) == 0) {
    const unsigned char *p;
    uint32_t value;

    *handled = TRUE;
    p = cmd+sizeof("BT1 baud ") - 1;
    res = UTIL1_ScanDecimal32uNumber(&p, &value);
    if (res!=ERR_OK) {
      CLS1_SendStr((unsigned char*)"*** invalid number!\r\n", io->stdErr);
      res = ERR_FAILED;
    } else {
      res = BT1_btSetBaud(value);
    }
  } else if (UTIL1_strncmp((char*)cmd, "BT1 cmd ", sizeof("BT1 cmd ") - 1) == 0) {
    *handled = TRUE;
    res = SendCommand(cmd + sizeof("BT1 cmd ") - 1, io);
  } else if (UTIL1_strncmp((char*)cmd, "BT1 send ", sizeof("BT1 send ") - 1) == 0) {
    word strSize, snt;
    const unsigned char *p;

    *handled = TRUE;
    p = cmd+sizeof("BT1 send ")-1;
    strSize = (word)UTIL1_strlen((char*)p);
    if (Serial1_SendBlock((unsigned char*)p, strSize, &snt) != ERR_OK) {
      CLS1_SendStr((unsigned char*)"FAILED sending string\r\n", io->stdErr);
      res = ERR_FAILED;
    }
  }
  return res;
}

/*
** ===================================================================
**     Method      :  BT1_RecvChar (component Bluetooth_EGBT)
**     Description :
**         Receives a character from the Bluetooth serial bridge
**     Parameters  :
**         NAME            - DESCRIPTION
**       * ch              - Pointer to character buffer
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
/*
byte BT1_RecvChar(byte *ch)
{
  *** Implemented as macro in the header file BT1.h
}
*/

/*
** ===================================================================
**     Method      :  BT1_SendChar (component Bluetooth_EGBT)
**     Description :
**         Sends a character to the Bluetooth serial bridge
**     Parameters  :
**         NAME            - DESCRIPTION
**         ch              - Character to be sent
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
/*
byte BT1_SendChar(byte ch)
{
  *** Implemented as macro in the header file BT1.h
}
*/

/*
** ===================================================================
**     Method      :  BT1_GetCharsInRxBuf (component Bluetooth_EGBT)
**     Description :
**         Returns the numbers of character in the receiver buffer.
**     Parameters  : None
**     Returns     :
**         ---             - Number of characters.
** ===================================================================
*/
/*
word BT1_GetCharsInRxBuf(void)
{
  *** Implemented as macro in the header file BT1.h
}
*/

/*
** ===================================================================
**     Method      :  BT1_StdIOKeyPressed (component Bluetooth_EGBT)
**     Description :
**         StdIO handler for Shell
**     Parameters  : None
**     Returns     :
**         ---             - True if there are characters in the
**                           input/RX buffer
** ===================================================================
*/
bool BT1_StdIOKeyPressed(void)
{
  return (bool)((BT1_GetCharsInRxBuf()==0U) ? FALSE : TRUE); /* true if there are characters in receive buffer */
}

/*
** ===================================================================
**     Method      :  BT1_StdIOReadChar (component Bluetooth_EGBT)
**     Description :
**         StdIO Handler for reading a character. It reads a zero byte
**         if there is no character.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * c               - Pointer to result character
**     Returns     : Nothing
** ===================================================================
*/
void BT1_StdIOReadChar(byte *c)
{
  if (BT1_RecvChar((uint8_t *)c) != ERR_OK) {
    /* failed to receive character: return a zero character */
    *c = '\0';
  }
}

/*
** ===================================================================
**     Method      :  BT1_StdIOSendChar (component Bluetooth_EGBT)
**     Description :
**         StdIO handler to sends a character 
**     Parameters  :
**         NAME            - DESCRIPTION
**         ch              - character to send
**     Returns     : Nothing
** ===================================================================
*/
void BT1_StdIOSendChar(byte ch)
{
  while (BT1_SendChar((uint8_t)ch)==ERR_TXFULL){} /* Send char */
}

/* END BT1. */

/*!
** @}
*/
/*
** ###################################################################
**
**     This file was created by Processor Expert 10.3 [05.09]
**     for the Freescale Kinetis series of microcontrollers.
**
** ###################################################################
*/
